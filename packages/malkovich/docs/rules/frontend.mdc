---
description: "Frontend development rules - Preact, CSS (modern nesting), DeepSignal, and component-driven architecture"
globs:
  - "packages/expressio/src/**"
  - "packages/pyrite/src/**"
  - "packages/malkovich/src/**"
  - "packages/common/components/**"
  - "packages/common/css/**"
  - "**/*.css"
  - "**/*.tsx"
alwaysApply: true
---

# Garage44 Frontend Development Rules

Frontend development guidelines for the Expressio AI-powered i18n tooling project.

## Tech Stack

- **Framework**: Preact with JSX (`jsx: "react-jsx"`, `jsxImportSource: "preact"`)
- **Styling**: CSS with modern nesting - NO inline styles, **NO BEM (Block Element Modifier) naming convention**
- **State**: DeepSignal (Proxy-based reactive objects) - NOT useState
- **Icons**: Icon component from common library - NOT direct SVG/font icons
- **Real-time**: WebSocket client for live updates
- **Build**: Bun bundler with hot reload

## Component Architecture

### Architecture Principles

**Component-Driven Design:**
- Each component = `.tsx` + `.css` file in `/packages/common/components/`
- Root element uses `.c-{component-name}` convention (e.g., `.c-button`, `.c-card`)
- Products import components (not utility classes)
- Custom styling in products = missing reusable component that should be extracted
- Use modern CSS nesting - **NEVER use BEM naming convention (no double underscores `__` or double dashes `--` for modifiers)**
- Components bring their own styling automatically

**Example Structure:**
```
/packages/common/components/ui/
‚îú‚îÄ‚îÄ button/
‚îÇ   ‚îú‚îÄ‚îÄ button.tsx       # Component logic
‚îÇ   ‚îî‚îÄ‚îÄ button.css       # Styles with .c-button root
‚îú‚îÄ‚îÄ card/
‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îî‚îÄ‚îÄ card.css         # Styles with .c-card root
‚îî‚îÄ‚îÄ app-layout/
    ‚îú‚îÄ‚îÄ app-layout.tsx
    ‚îî‚îÄ‚îÄ app-layout.css   # Styles with .c-app-layout root
```

### Component Structure
```
src/components/
‚îú‚îÄ‚îÄ elements/     # Reusable UI components
‚îú‚îÄ‚îÄ pages/        # Page-level components
‚îî‚îÄ‚îÄ main/         # Layout and shell components
```

### Development Patterns

**Preact Components:**
```tsx
// ‚úÖ Proper component structure
interface TranslationProps {
    translations: Translation[];
    onSelect?: (id: string) => void;
}

export const TranslationGroup = ({ translations, onSelect }: TranslationProps) => {
  const selectedId = useSignal<string | null>(null);

  return (
    <div class="translation-group">
      {translations.map(t => (
        <div key={t.id} onClick={() => selectedId.value = t.id}>
          {t.key}
        </div>
      ))}
    </div>
  );
};
```

**State Management with DeepSignal:**
```tsx
// ‚úÖ Use DeepSignal - regular JavaScript objects that are reactive
import {deepSignal} from 'deepsignal'

// ‚úÖ CRITICAL: Define state OUTSIDE component to prevent infinite re-renders
// For shared state across component instances:
const state = deepSignal({
    username: '',
    password: '',
    activeWords: [] as AnimatedWord[],
    // ... other state properties
})

const MyComponent = () => {
  // ‚úÖ State is stable across renders
  return <div onClick={() => state.count++}>{state.count}</div>
}

// ‚úÖ For per-instance component state, use useRef to store DeepSignal
const PerInstanceComponent = () => {
  const stateRef = useRef(deepSignal({
    content: '',
    loading: true,
    error: null as string | null,
  }))
  const state = stateRef.current

  // ‚úÖ State is created once per component instance, stable across renders
  return <div onClick={() => state.count++}>{state.count}</div>
}

// ‚ùå DON'T define state inside component directly - causes infinite re-renders
const BadComponent = () => {
  const state = deepSignal({count: 0}) // Wrong! Recreated on every render
  return <div onClick={() => state.count++}>{state.count}</div>
}

// ‚úÖ Real example from login component
const LoginComponent = () => {
  // State is defined outside component - stable across renders
  const {validation, isValid, resetTouched} = createValidator({
    password: [state.$password, required('Password is required')],
    username: [state.$username, required('Username is required')],
  })

  return <div>
    <FieldText
      model={state.$username}  // Pass signal directly
      label="Username"
      validation={validation.value.username}
    />
    <FieldText
      model={state.$password}  // Pass signal directly
      label="Password"
      type="password"
      validation={validation.value.password}
    />
  </div>
}

// ‚ùå Don't use useState for component state - ALWAYS use DeepSignal
const BadComponent = () => {
  const [count, setCount] = useState(0) // Wrong! Use deepSignal instead
  const [loading, setLoading] = useState(false) // Wrong! Use deepSignal instead
}
```

### Advanced DeepSignal Patterns

**Field Component Integration:**
```tsx
// ‚úÖ Field components with signals and validation
import {FieldText, FieldSelect} from '@garage44/common/components'
import {createValidator, required} from '@garage44/common/lib/validation'

// State defined outside component (CRITICAL for stability)
const state = deepSignal({
    username: '',
    password: '',
    workspace_id: null
})

const LoginForm = () => {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  // ‚úÖ Validation with signals
  const {validation, isValid, resetTouched} = createValidator({
    password: [state.$password, required('Password is required')],
    username: [state.$username, required('Username is required')],
  })

  return (
    <div>
      <FieldText
        model={state.$username}  // ‚úÖ Pass signal directly
        label="Username"
        placeholder="Enter username"
        validation={validation.value.username}
      />
      <FieldText
        model={state.$password}  // ‚úÖ Pass signal directly
        label="Password"
        type="password"
        validation={validation.value.password}
      />
      <FieldSelect
        model={state.$workspace_id}  // ‚úÖ Signal for select
        label="Workspace"
        options={workspaces.map(w => ({id: w.id, name: w.name}))}
      />
    </div>
  )
}
```

**Accessing Underlying Signals:**
```tsx
// ‚úÖ Access underlying signal with $ prefix for performance
const state = deepSignal({workspace_id: null})

// Pass signal directly to form fields (prevents component re-renders)
const WorkspaceSelector = () => (
  <FieldSelect
    model={state.$workspace_id}
    onChange={async(workspace_id) => {
      // Handle workspace change
      $s.workspace = await ws.get(`/api/workspaces/${workspace_id}`)
    }}
    options={$s.workspaces.map(i => ({id: i.workspace_id, name: i.workspace_id}))}
  />
)
```

**useEffect with Signals:**
```tsx
// ‚úÖ Proper useEffect with signals - use effect() from @preact/signals to watch DeepSignal
import {effect} from '@preact/signals'
import {deepSignal} from 'deepsignal'

const MarkdownComponent = () => {
  const stateRef = useRef(deepSignal({
    content: '',
    loading: true,
    error: null as string | null,
  }))
  const state = stateRef.current

  // ‚úÖ Use effect() to watch DeepSignal state changes
  useEffect(() => {
    const unsubscribe = effect(() => {
      // Access state properties to track changes
      const content = state.content
      const loading = state.loading

      if (!loading && content) {
        // React to state changes immediately
        renderContent(content)
      }
    })

    return unsubscribe
  }, [state])

  // ‚úÖ Component re-renders when state properties are accessed in JSX
  if (state.loading) return <div>Loading...</div>
  if (state.error) return <div>Error: {state.error}</div>
  return <div>{state.content}</div>
}

// ‚ùå DON'T use useState - always use DeepSignal
const BadComponent = () => {
  const [loading, setLoading] = useState(false) // Wrong!
  const [content, setContent] = useState('') // Wrong!
}
```

**Global State Access:**
```tsx
// ‚úÖ Access global state with $s
import {$s} from '@/app'

const WorkspaceComponent = () => {
  // Access global workspace state
  if (!$s.workspace) return null

  return <div>
    <h1>{$s.workspace.config.workspace_id}</h1>
    <p>Authenticated: {$s.user.authenticated}</p>
  </div>
}
```

**Store Pattern (Global State):**
```tsx
// ‚úÖ Global store pattern from common/lib/store.ts
import {deepSignal} from 'deepsignal'

class Store {
  state = deepSignal({})

  load(persistantState, volatileState) {
    this.persistantState = copyObject(persistantState)

    let restoredState
    try {
      restoredState = JSON.parse(localStorage.getItem('store'))
    } catch (err) {
      restoredState = {}
    }

    Object.assign(this.state, mergeDeep(mergeDeep(persistantState, restoredState), volatileState))
  }

  save() {
    localStorage.setItem('store', JSON.stringify(this.filterKeys(this.state, this.persistantState)))
  }
}
```

## CSS Guidelines

**üö® CRITICAL: NEVER use BEM (Block Element Modifier) naming convention. ALWAYS use modern CSS nesting instead.**

### NO BEM Naming Convention

**‚ùå NEVER use BEM (Block Element Modifier) naming:**
- No double underscores `__` for elements (e.g., `.c-button__icon`)
- No double dashes `--` for modifiers (e.g., `.c-button--disabled`)
- No BEM-style class names anywhere in the codebase

**‚úÖ ALWAYS use modern CSS nesting instead:**
```css
/* ‚úÖ Correct: Use nesting */
.c-button {
    display: flex;

    .icon {
        width: 16px;
    }

    &.disabled {
        opacity: 0.5;
    }
}

/* ‚ùå Wrong: BEM naming */
.c-button__icon { }
.c-button--disabled { }
```

### NO CSS Imports in Components

**‚ùå NEVER import CSS files in component code:**
- CSS files are automatically collected and bundled by Bunchy
- Bunchy scans component directories and bundles all `.css` files automatically
- Importing CSS in components is unnecessary and should be avoided

**‚úÖ Correct approach:**
- Place CSS files alongside components (e.g., `button.tsx` + `button.css`)
- Bunchy automatically discovers and bundles component CSS files
- No import statements needed in component code

```tsx
// ‚úÖ Correct: No CSS import needed
import {Button} from '../button/button'
import {Icon} from '../icon/icon'

export function MyComponent() {
  return <div class="c-my-component">...</div>
}

// ‚ùå Wrong: Don't import CSS files
import './my-component.css'  // Wrong! Bunchy handles this automatically
```

**How Bunchy handles CSS:**
- Automatically scans `src/components/**/*.css` and `packages/common/components/**/*.css`
- Bundles all component CSS into `components.<buildId>.css`
- Hot-reloads CSS changes without page refresh
- See `packages/bunchy/tasks.ts` for implementation details

### Use Existing Variables
```css
/* ‚úÖ Use predefined CSS custom properties */
.c-translation-item {
    margin: var(--spacer-1);
    padding: var(--spacer-2);
    font-size: var(--font-d);
}

/* ‚ùå Don't use arbitrary values */
.bad-item {
    margin: 1rem;
    padding: 2rem;
}
```

### Component-Scoped Styles with Modern Nesting
```css
/* translation-group.css */
.c-translation-group {
    display: flex;
    flex-direction: column;

    /* ‚úÖ Use modern CSS nesting */
    .item {
        padding: var(--spacer-1);

        &:hover {
            background: var(--surface-2);
        }
    }

    /* ‚úÖ State modifiers with nesting */
    &.expanded {
        max-height: none;
    }
}

/* ‚ùå Don't use BEM naming */
.c-translation-group__item { /* Wrong! Use nesting instead */
}
```

### NO Inline Styles
```tsx
// ‚ùå Avoid inline styles
<div style={{ margin: '1rem' }}>Bad</div>

// ‚úÖ Use CSS classes
<div class="translation-item">Good</div>
```

## WebSocket Client Patterns

**Real-time Translation Updates:**
```tsx
import {$s, ws} from '@/app'
import {events} from '@garage44/common/app'
import {pathCreate, pathDelete, pathUpdate} from '@garage44/common/lib/paths.ts'

// ‚úÖ Real WebSocket usage from translations component
events.on('app:init', () => {
  ws.on('/i18n/sync', ({create_tags, delete_tags, modify_tags}) => {
    for (const tag of create_tags) {
      const {path, value} = tag
      pathCreate($s.workspace.i18n, path, value, $s.workspace.config.languages.target, value.target)
    }
    for (const tag of delete_tags) {
      const {path} = tag
      pathDelete($s.workspace.i18n, path)
    }
    for (const tag of modify_tags) {
      const {path, value} = tag
      pathUpdate($s.workspace.i18n, path, value)
    }
  })

  // Handle full i18n state updates
  ws.on('/i18n/state', ({workspace_id, i18n, timestamp}) => {
    if (!$s.workspace || $s.workspace.config.workspace_id !== workspace_id) {
      return
    }

    // Check if this update is newer (prevents race conditions)
    if (!$s.workspace.lastStateUpdateTime || timestamp > ($s.workspace.lastStateUpdateTime ?? 0)) {
      $s.workspace.i18n = i18n
      $s.workspace.lastStateUpdateTime = timestamp
    }
  })
})
```

**WebSocket API Calls:**
```tsx
// ‚úÖ Direct WebSocket API usage
const handleUndo = async () => {
  ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/undo`, {})
}

const handleRedo = async () => {
  ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/redo`, {})
}

// ‚úÖ WebSocket connection management
const Main = () => {
  useEffect(() => {
    (async() => {
      const context = await api.get('/api/context')
      if (context.authenticated) {
        ws.connect() // Connect WebSocket when authenticated
      }
    })()
  }, [])
}
```

## Translation Interface Patterns

### Translation Workflow UX
1. **Translation Groups**: Organize related translations logically
2. **Real-time Progress**: Show live translation status updates
3. **Validation States**: Display errors/warnings clearly
4. **Workspace Context**: Always show current workspace state

### UI Components for i18n
```tsx
// Translation status indicator
const TranslationStatus = ({ status }: { status: TranslationStatus }) => (
  <span class={`translation-status translation-status--${status}`}>
    {status === 'pending' && '‚è≥'}
    {status === 'translated' && '‚úÖ'}
    {status === 'reviewed' && 'üîç'}
  </span>
);

// Translation result display
const TranslationResult = ({ original, translated, confidence }) => (
  <div class="translation-result">
    <div class="translation-result__original">{original}</div>
    <div class="translation-result__translated">{translated}</div>
    <div class="translation-result__confidence">
      Confidence: {Math.round(confidence * 100)}%
    </div>
  </div>
);
```

### Icon Component Usage

**CRITICAL: Always use the Icon component from `@garage44/common/components` - NEVER use inline SVG or direct icon markup.**

**Icon Management:**
- All icons must be defined in `packages/common/components/ui/icon/icon.tsx` in the `svg` object
- If an icon is missing, add it to `icon.tsx` first, then reference it via the Icon component
- Icons use SVG path data (fill paths, not stroke paths)
- Icon names should be descriptive and follow existing naming conventions

```tsx
// ‚úÖ Use Icon component from common library
import {Icon} from '@garage44/common/components'

const TranslateButton = () => (
  <button class="translate-button">
    <Icon name="translate" />
    Translate
  </button>
)

// ‚úÖ Real example from main component
const Navigation = () => (
  <div class="menu-group">
    <Link activeClassName="active" href="/">
      <Icon name="settings" type="info"/>
      <span>{$t('menu.settings')}</span>
    </Link>
    <Link href={`/workspaces/${$s.workspace.config.workspace_id}/translations`}>
      <Icon name="translate" type="info"/>
      <span>{$t('menu.workspace.translations')}</span>
    </Link>
  </div>
)

// ‚úÖ Icon with click handlers
const HistoryActions = () => (
  <div class="history-actions">
    <Icon
      name="chevron_left"
      onClick={async() => {
        ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/undo`, {})
      }}
      tip="Undo"
      type="info"
    />
    <Icon
      name="chevron_right"
      onClick={async() => {
        ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/redo`, {})
      }}
      tip="Redo"
      type="info"
    />
  </div>
)

// ‚ùå Don't use direct SVG or font icons
const BadComponent = () => (
  <div>
    <svg viewBox="0 0 24 24">...</svg> {/* Wrong! */}
    <i class="fas fa-check"></i> {/* Wrong! */}
    <span>üîç</span> {/* Wrong! Use Icon component */}
  </div>
)

// ‚ùå Don't use inline SVG paths
const BadComponent = () => (
  <button>
    <svg width="24" height="24" viewBox="0 0 24 24">
      <path d="M3 6h18M3 12h18M3 18h18" />
    </svg>
  </button>
)

// ‚úÖ If icon is missing, add it to icon.tsx first
// In packages/common/components/ui/icon/icon.tsx:
// menu_hamburger: 'M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z',
// Then use it:
const GoodComponent = () => (
  <button>
    <Icon name="menu_hamburger" size="d" />
  </button>
)
```

## File Organization

### Import Order
```tsx
// Global app imports
import {$s, ws} from '@/app'
import {$t, api, notify} from '@garage44/common/app'

// External dependencies
import {h} from 'preact'
import {useEffect} from 'preact/hooks'
import {Router, route} from 'preact-router'

// Common package imports
import {Icon, Notifications} from '@garage44/common/components'
import {deepSignal} from 'deepsignal'
import {classes} from '@garage44/common/lib/utils'

// Component imports
import {TranslationGroup} from '@/components/elements'

// ‚ùå DO NOT import CSS files - Bunchy handles this automatically
// import './translation-group.css'  // Wrong!
```

### File Naming Conventions
- Components: `translation-group.tsx`
- Styles: `translation-group.css` (modern CSS with nesting)
- Barrel exports: `elements.ts`
- Hooks: `useWebSocketSubscription.ts`

### CSS Class Naming
- Root element: `.c-{component-name}` (e.g., `.c-button`, `.c-card`)
- Child elements: Use nesting, not BEM (e.g., `.item` inside `.c-card`, not `.c-card__item`)
- State modifiers: Use `&.modifier` nesting (e.g., `&.active`, `&.disabled`)

## Performance Optimization

### Translation Data Handling
- Lazy load large translation sets
- Virtualize translation lists with 100+ items
- Debounce search/filter inputs (300ms)
- Use signal batching for bulk updates

### Re-render Optimization
```tsx
// ‚úÖ Local state for component filtering
import {deepSignal} from 'deepsignal'

const TranslationComponent = () => {
  const localState = deepSignal({
    filter: '',
    sort: 'asc' as 'asc' | 'desc'
  })

  // Filter translations directly - reactive to localState changes
  const filteredTranslations = $s.workspace.i18n.filter(t =>
    t.key.toLowerCase().includes(localState.filter.toLowerCase())
  )

  return <div>
    <input
      value={localState.filter}
      onInput={e => localState.filter = (e.target as HTMLInputElement).value}
    />
    <TranslationGroup
      group={{_id: 'root', ...$s.workspace.i18n}}
      filter={localState.filter}
      sort={localState.sort}
    />
  </div>
}

// ‚úÖ Pass signals to form fields for performance
const WorkspaceSelector = () => (
  <FieldSelect
    model={state.$workspace_id}  // Signal passed directly
    onChange={async(workspace_id) => {
      $s.workspace = await ws.get(`/api/workspaces/${workspace_id}`)
    }}
    options={$s.workspaces.map(i => ({id: i.workspace_id, name: i.workspace_id}))}
  />
)

// ‚ùå Don't recreate objects in render
const BadList = () => {
  return translations.map(t => <Item data={{...t, extra: 'data'}} />) // Creates new objects
}
```

## Accessibility for i18n

- Use semantic HTML for translation content
- Provide ARIA labels for translation status
- Ensure keyboard navigation works for translation tables
- Test with screen readers for multilingual content
- Support high contrast mode for translation interfaces

## Development Workflow

### Hot Reload Behavior
- `.tsx` changes: Component hot reload
- `.css` changes: Style injection without reload
- Signal state: Preserved during development
- WebSocket: Automatically reconnects

### Debugging Frontend
- Use Preact DevTools for component inspection
- Monitor WebSocket messages in Network tab
- Check signal updates in browser console
- Validate translation data flow in real-time

## Code Style and ESLint Compliance

**üö® CRITICAL: See `@linting.mdc` for complete linting requirements.**

**All code must pass ESLint checks before committing.**

### Before Committing

Always run lint checks and fix any errors before committing:

```bash
# Check TypeScript/TSX files
bun run lint:ts

# Check CSS files (if CSS was modified)
bun run lint:css
```

**Auto-fixing:**
- Many formatting issues can be auto-fixed: `bun run lint:ts --fix`
- Always verify auto-fixes don't break functionality
- Fix any remaining errors manually according to ESLint output

**ESLint configuration:**
- Rules are defined in `eslint.config.js` at the workspace root
- Follow ESLint error messages to fix code style issues
- Do not commit code with linting errors

**For detailed linting rules and workflow, see `@linting.mdc`.**

## Common Anti-patterns

‚ùå **Don't do:**
- Use useState instead of deepSignal for component state - **ALWAYS use DeepSignal**
- Define deepSignal state directly inside components (causes infinite re-renders) - use useRef instead
- Include functions in useEffect dependencies that depend on signals
- Use setTimeout/requestAnimationFrame for state-driven rendering - render synchronously
- Create inline styles - use CSS classes with modern nesting
- Use direct SVG/font icons - use Icon component
- Use inline SVG paths - add icon to icon.tsx and use Icon component
- Use BEM naming (`.c-button__icon`) - use nesting instead
- Import CSS files in components - Bunchy handles this automatically
- Mutate props directly
- Block the UI during translation API calls
- Forget to handle WebSocket disconnections
- Use .value syntax with DeepSignal (it's not needed)
- Forget to import global state with `{$s, ws} from '@/app'`
- Create utility CSS classes - create components instead
- Pass non-signal values to Field model props
- Forget to pass validation prop to Field components
- Commit code without running lint checks

‚úÖ **Do:**
- Define deepSignal state OUTSIDE components for shared state, or use useRef for per-instance state
- Use deepSignal for ALL component-level reactive state (never useState)
- Use useRef(deepSignal({...})) for per-instance component state
- Use effect() from @preact/signals to watch DeepSignal changes in useEffect
- Render synchronously when state changes - avoid setTimeout/requestAnimationFrame delays
- Pass signals directly to Field components (model={state.$field})
- Include validation prop in Field components
- Access global state through $s object
- Use existing CSS custom properties (var(--spacer-1), var(--font-d))
- Use Icon component from @garage44/common/components
- Handle loading/error states gracefully with DeepSignal
- Access underlying signals with $ prefix for form fields
- Use WebSocket events with `events.on('app:init', ...)` pattern
- Test with multiple languages and character sets
- Use modern CSS nesting in component CSS files
- Extract reusable patterns as components, not utility classes
- Keep useEffect dependencies minimal and stable
- Always run `bun run lint:ts` and `bun run lint:css` before committing