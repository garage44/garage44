---
description: "Architecture Decision Records (ADR) consultation workflow - guides AI to maintain architectural consistency"
globs:
  - "**/*"
alwaysApply: false
---

# Garage44 Cursor AI Rules - ADR Consultation

This file contains rules for AI assistants working on the Garage44 monorepo. These rules ensure architectural consistency by consulting Architecture Decision Records (ADRs) before making significant decisions.

## Project Overview

Garage44 is a monorepo containing multiple applications (Expressio, Pyrite, Styleguide) with shared packages (common, bunchy). The projects follow specific architectural patterns and technology choices documented in Architecture Decision Records (ADRs).

## Architecture Decision Records (ADRs)

**Critical**: Before creating plans for significant architectural or technology decisions, consult existing ADRs to ensure consistency with established patterns and principles.

### 1. Consult Existing ADRs

Read relevant ADRs in `adr/` before making decisions:

- **Start here**: `adr/README.md` - Overview, index, and core principles
- **Learn patterns**: `adr/guide/PATTERNS.md` - Reusable decision patterns
- **Get guidance**: `adr/guide/AI-REASONING-GUIDE.md` - How to use ADRs effectively

**Search strategies**:
```bash
# Use codebase_search for topics
"How are WebSocket connections handled?" → ADR-004, ADR-006

# Use grep for specific technologies
grep -i "websocket\|bun\|preact" adr/*.md
```

### 2. Cite ADRs in Plans

Reference specific ADRs to show consistency with established patterns:

```markdown
## Architectural Alignment

This approach follows:
- ADR-003 (Bun Runtime): Using Bun's native features for...
- ADR-004 (Preact/WebSocket): Implementing real-time updates via...
- Pattern: Technology Adoption Pattern (see PATTERNS.md)
```

### 3. Flag Deviations

If proposing something that contradicts existing ADRs:
- **Explicitly call out** the contradiction
- **Justify** why deviation is necessary
- **Suggest** updating or superseding the old ADR

Example:
```markdown
⚠️ **Deviation from ADR-011**: Proposing SCSS instead of native CSS because [specific reason]. This may require updating ADR-011 or creating an exception for [use case].
```

### 4. Suggest New ADRs

Recommend creating an ADR when making architecturally significant decisions:

**Always create ADR for:**
- Technology choices (language, framework, tool, runtime)
- Architectural patterns (structure, communication, boundaries)
- System-wide changes (design system, logging, build process)
- Tool adoption/replacement (linters, bundlers, etc.)

**Consider ADR for:**
- Setting precedent within a package
- Changes to API design patterns
- Developer workflow modifications

**Skip ADR for:**
- Implementation details within existing patterns
- Bug fixes without architectural changes
- Routine dependency updates

### 5. Plan-to-ADR Workflow

After successful implementation of significant decisions:
1. Document the decision as an ADR
2. Use `adr/guide/TEMPLATE.md` for structure
3. Follow `adr/guide/PLAN-TO-ADR-TEMPLATE.md` for conversion
4. Include lessons learned during implementation
5. Add to `adr/README.md` index

## Core Architectural Principles

Validate decisions against these principles (from `adr/README.md`):

### 1. Real-time First
- Default to WebSocket communication for user-facing features
- Prioritize live updates over request/response patterns
- Build collaboration features with real-time synchronization
- **Reference**: ADR-004, ADR-006

### 2. Package Boundary Discipline
- Separate packages by business domain, not technical layers
- Respect licensing boundaries (AGPL for core, MIT for utilities)
- Avoid circular dependencies between packages
- **Reference**: ADR-001

### 3. Developer Experience Priority
- Choose tools that optimize for fast iteration (Bun, TypeScript, hot reload)
- Prefer modern standards over legacy compatibility (ES2023, ES modules)
- Simplify toolchain complexity where possible
- Adopt Rust-based tooling for performance gains (OxLint, Bun)
- **Reference**: ADR-003, ADR-007, ADR-010

### 4. Commercial/Community Balance
- Protect core business logic with AGPL
- Enable community growth with MIT utilities
- Build extensible foundations for future commercial features
- **Reference**: ADR-002

### 5. LLM-Optimized Strategic Reasoning
- Structure documentation to support AI-assisted decision making
- Maintain clear traceability between technical and business decisions
- Centralize strategic context for improved reasoning capabilities
- **Reference**: ADR-009

### 6. Unified Design System
- Maintain consistent visual identity across all projects
- Share design tokens and components through `@garage44/common` package
- Use modern CSS features (native nesting, custom properties, OKLCH colors)
- **Reference**: ADR-011, ADR-012

## Technology Stack (Established by ADRs)

**Verify compatibility with established stack before proposing changes:**

- **Runtime**: Bun (ADR-003)
- **Frontend**: Preact with JSX (ADR-004)
- **State Management**: DeepSignal (ADR-004)
- **Communication**: WebSocket-first (ADR-004, ADR-006)
- **Server**: Bun.serve() - NOT Express.js (ADR-007)
- **CSS**: Modern native CSS with OKLCH colors (ADR-011)
- **Linting**: OxLint - NOT ESLint (ADR-010)
- **Package Manager**: Bun workspaces (ADR-001, ADR-003)
- **Module System**: ES modules (type: "module") (ADR-003)

## Decision Types & Patterns

Use appropriate pattern from `adr/guide/PATTERNS.md`:

**Technology Choice** (ADR-003, ADR-010):
- Evaluate: DX (9/10), Performance (8/10), Ecosystem (7/10), Team (6/10)
- Have fallback plan, proof-of-concept validation
- Measure build times, bundle sizes, developer feedback

**Migration** (ADR-006, ADR-007, ADR-011):
- Incremental approach with rollback plan
- Validate with small scope first
- Maintain old system during transition
- Document lessons learned

**Architecture** (ADR-001, ADR-004):
- Define clear boundaries and domains
- Consider scalability and maintainability
- Validate against architectural principles
- Document coupling changes

**Design System** (ADR-011, ADR-012):
- Use shared tokens from `@garage44/common/css/theme.css`
- Generic components in common, project-specific in apps
- Ensure accessibility (WCAG compliance)

**Tool Replacement** (ADR-010):
- Benchmark current vs new (10x improvement target)
- Verify feature parity
- Validate on real codebase before committing
- Simplify toolchain when possible

## Quick Consistency Checks

Before proposing changes, verify:

- [ ] Does this use WebSocket for real-time features? (ADR-004, ADR-006)
- [ ] Does this respect package boundaries? (ADR-001)
- [ ] Does this use Bun runtime features? (ADR-003)
- [ ] Does this use modern native CSS? (ADR-011)
- [ ] Does this use shared design tokens? (ADR-012)
- [ ] Does this follow established patterns? (PATTERNS.md)
- [ ] Is this consistent with architectural principles?

## Common Anti-Patterns to Avoid

Based on ADRs, explicitly avoid:

**Technology**:
- ❌ Express.js (use Bun.serve per ADR-007)
- ❌ ESLint (use OxLint per ADR-010)
- ❌ SCSS (use native CSS per ADR-011)
- ❌ Node.js-specific APIs in shared code (use isomorphic per ADR-008)

**Architecture**:
- ❌ REST for real-time user features (use WebSocket per ADR-004)
- ❌ Circular package dependencies (violates ADR-001)
- ❌ Business logic in common package (violates ADR-001)

**Design System**:
- ❌ Inline styles (use CSS classes per ADR-011)
- ❌ Importing individual CSS files (use theme.css per ADR-011)
- ❌ Hardcoded colors/spacing (use design tokens per ADR-012)

## Example: Evaluating New Feature

```markdown
## Feature: Real-time Notifications

**ADR Consultation**:
- ADR-004: Use WebSocket for real-time features ✅
- ADR-012: Use design tokens for UI components ✅
- Pattern: Architecture Pattern (defining notification system)

**Architectural Alignment**:
- Real-time First: Using WebSocket ✅
- Package Boundaries: Notification logic in expressio, UI in common ✅
- Unified Design System: Using common design tokens ✅

**Implementation**:
- Communication: WebSocket subscription to /notifications channel
- UI: Notification component using design tokens from common
- State: DeepSignal for notification state management

**ADR Needed**: No - follows existing patterns (ADR-004, ADR-012)
```

## Resources

- **ADR Index**: `adr/README.md`
- **Decision Patterns**: `adr/guide/PATTERNS.md`
- **AI Guide**: `adr/guide/AI-REASONING-GUIDE.md`
- **ADR Template**: `adr/guide/TEMPLATE.md`
- **Plan Conversion**: `adr/guide/PLAN-TO-ADR-TEMPLATE.md`

## Notes for AI Assistants

1. **Always start** by reading relevant ADRs before proposing architectural changes
2. **Cite specific ADRs** in plans to demonstrate consistency
3. **Flag contradictions** explicitly with justification
4. **Suggest ADRs** for architecturally significant decisions
5. **Use patterns** from guide/PATTERNS.md as decision frameworks
6. **Check principles** against README.md core principles
7. **Document learnings** to improve future ADRs

This approach ensures continuous improvement through the feedback loop:
**Plan → Build → ADR → Learning → Better Future Plans**
