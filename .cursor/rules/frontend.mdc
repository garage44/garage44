---
description: "Frontend development rules - Preact, CSS (modern nesting), DeepSignal, and component-driven architecture"
globs:
  - "packages/expressio/src/**"
  - "packages/pyrite/src/**"
  - "packages/styleguide/src/**"
  - "packages/common/components/**"
  - "packages/common/css/**"
  - "**/*.css"
  - "**/*.tsx"
alwaysApply: true
---

# Expressio Frontend Development Rules

Frontend development guidelines for the Expressio AI-powered i18n tooling project.

## Tech Stack

- **Framework**: Preact with JSX (`jsx: "react-jsx"`, `jsxImportSource: "preact"`)
- **Styling**: CSS with modern nesting - NO inline styles, NO BEM
- **State**: DeepSignal (Proxy-based reactive objects) - NOT useState
- **Icons**: Icon component from common library - NOT direct SVG/font icons
- **Real-time**: WebSocket client for live updates
- **Build**: Bun bundler with hot reload

## Component Architecture

### Architecture Principles

**Component-Driven Design:**
- Each component = `.tsx` + `.css` file in `/packages/common/components/`
- Root element uses `.c-{component-name}` convention (e.g., `.c-button`, `.c-card`)
- Products import components (not utility classes)
- Custom styling in products = missing reusable component that should be extracted
- Use modern CSS nesting (no BEM)
- Components bring their own styling automatically

**Example Structure:**
```
/packages/common/components/ui/
├── button/
│   ├── button.tsx       # Component logic
│   └── button.css       # Styles with .c-button root
├── card/
│   ├── card.tsx
│   └── card.css         # Styles with .c-card root
└── app-layout/
    ├── app-layout.tsx
    └── app-layout.css   # Styles with .c-app-layout root
```

### Component Structure
```
src/components/
├── elements/     # Reusable UI components
├── pages/        # Page-level components
└── main/         # Layout and shell components
```

### Development Patterns

**Preact Components:**
```tsx
// ✅ Proper component structure
interface TranslationProps {
    translations: Translation[];
    onSelect?: (id: string) => void;
}

export const TranslationGroup = ({ translations, onSelect }: TranslationProps) => {
  const selectedId = useSignal<string | null>(null);

  return (
    <div class="translation-group">
      {translations.map(t => (
        <div key={t.id} onClick={() => selectedId.value = t.id}>
          {t.key}
        </div>
      ))}
    </div>
  );
};
```

**State Management with DeepSignal:**
```tsx
// ✅ Use DeepSignal - regular JavaScript objects that are reactive
import {deepSignal} from 'deepsignal'

// ✅ CRITICAL: Define state OUTSIDE component to prevent infinite re-renders
const state = deepSignal({
    username: '',
    password: '',
    activeWords: [] as AnimatedWord[],
    // ... other state properties
})

const MyComponent = () => {
  // ✅ State is stable across renders
  return <div onClick={() => state.count++}>{state.count}</div>
}

// ❌ DON'T define state inside component - causes infinite re-renders
const BadComponent = () => {
  const state = deepSignal({count: 0}) // Wrong! Recreated on every render
  return <div onClick={() => state.count++}>{state.count}</div>
}

// ✅ Real example from login component
const LoginComponent = () => {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  // State is defined outside component - stable across renders
  const {validation, isValid, resetTouched} = createValidator({
    password: [state.$password, required('Password is required')],
    username: [state.$username, required('Username is required')],
  })

  return <div>
    <FieldText
      model={state.$username}  // Pass signal directly
      label="Username"
      validation={validation.value.username}
    />
    <FieldText
      model={state.$password}  // Pass signal directly
      label="Password"
      type="password"
      validation={validation.value.password}
    />
  </div>
}

// ❌ Don't use useState for component state
const BadComponent = () => {
  const [count, setCount] = useState(0) // Wrong! Use deepSignal instead
}
```

### Advanced DeepSignal Patterns

**Field Component Integration:**
```tsx
// ✅ Field components with signals and validation
import {FieldText, FieldSelect} from '@garage44/common/components'
import {createValidator, required} from '@garage44/common/lib/validation'

// State defined outside component (CRITICAL for stability)
const state = deepSignal({
    username: '',
    password: '',
    workspace_id: null
})

const LoginForm = () => {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  // ✅ Validation with signals
  const {validation, isValid, resetTouched} = createValidator({
    password: [state.$password, required('Password is required')],
    username: [state.$username, required('Username is required')],
  })

  return (
    <div>
      <FieldText
        model={state.$username}  // ✅ Pass signal directly
        label="Username"
        placeholder="Enter username"
        validation={validation.value.username}
      />
      <FieldText
        model={state.$password}  // ✅ Pass signal directly
        label="Password"
        type="password"
        validation={validation.value.password}
      />
      <FieldSelect
        model={state.$workspace_id}  // ✅ Signal for select
        label="Workspace"
        options={workspaces.map(w => ({id: w.id, name: w.name}))}
      />
    </div>
  )
}
```

**Accessing Underlying Signals:**
```tsx
// ✅ Access underlying signal with $ prefix for performance
const state = deepSignal({workspace_id: null})

// Pass signal directly to form fields (prevents component re-renders)
const WorkspaceSelector = () => (
  <FieldSelect
    model={state.$workspace_id}
    onChange={async(workspace_id) => {
      // Handle workspace change
      $s.workspace = await ws.get(`/api/workspaces/${workspace_id}`)
    }}
    options={$s.workspaces.map(i => ({id: i.workspace_id, name: i.workspace_id}))}
  />
)
```

**useEffect with Signals:**
```tsx
// ✅ Proper useEffect with signals - avoid infinite loops
const LoginComponent = () => {
  const [loading, setLoading] = useState(false)

  // State defined outside component (prevents recreation)
  const state = deepSignal({
    username: '',
    password: ''
  })

  const handleKeyPress = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Enter' && !loading) {
      handleLogin()
    }
  }, [loading, handleLogin])

  // ✅ useEffect with minimal dependencies
  useEffect(() => {
    document.addEventListener('keydown', handleKeyPress)
    return () => {
      document.removeEventListener('keydown', handleKeyPress)
    }
  }, [animated]) // ✅ Only depend on stable props, not functions

  // ❌ DON'T include functions in dependency array if they depend on signals
  // This causes infinite re-renders:
  // }, [animated, handleKeyPress]) // Wrong!
}
```

**Global State Access:**
```tsx
// ✅ Access global state with $s
import {$s} from '@/app'

const WorkspaceComponent = () => {
  // Access global workspace state
  if (!$s.workspace) return null

  return <div>
    <h1>{$s.workspace.config.workspace_id}</h1>
    <p>Authenticated: {$s.user.authenticated}</p>
  </div>
}
```

**Store Pattern (Global State):**
```tsx
// ✅ Global store pattern from common/lib/store.ts
import {deepSignal} from 'deepsignal'

class Store {
  state = deepSignal({})

  load(persistantState, volatileState) {
    this.persistantState = copyObject(persistantState)

    let restoredState
    try {
      restoredState = JSON.parse(localStorage.getItem('store'))
    } catch (err) {
      restoredState = {}
    }

    Object.assign(this.state, mergeDeep(mergeDeep(persistantState, restoredState), volatileState))
  }

  save() {
    localStorage.setItem('store', JSON.stringify(this.filterKeys(this.state, this.persistantState)))
  }
}
```

## CSS Guidelines

### Use Existing Variables
```css
/* ✅ Use predefined CSS custom properties */
.c-translation-item {
    margin: var(--spacer-1);
    padding: var(--spacer-2);
    font-size: var(--font-d);
}

/* ❌ Don't use arbitrary values */
.bad-item {
    margin: 1rem;
    padding: 2rem;
}
```

### Component-Scoped Styles with Modern Nesting
```css
/* translation-group.css */
.c-translation-group {
    display: flex;
    flex-direction: column;

    /* ✅ Use modern CSS nesting */
    .item {
        padding: var(--spacer-1);

        &:hover {
            background: var(--surface-2);
        }
    }

    /* ✅ State modifiers with nesting */
    &.expanded {
        max-height: none;
    }
}

/* ❌ Don't use BEM naming */
.c-translation-group__item { /* Wrong! Use nesting instead */
}
```

### NO Inline Styles
```tsx
// ❌ Avoid inline styles
<div style={{ margin: '1rem' }}>Bad</div>

// ✅ Use CSS classes
<div class="translation-item">Good</div>
```

## WebSocket Client Patterns

**Real-time Translation Updates:**
```tsx
import {$s, ws} from '@/app'
import {events} from '@garage44/common/app'
import {pathCreate, pathDelete, pathUpdate} from '@garage44/common/lib/paths.ts'

// ✅ Real WebSocket usage from translations component
events.on('app:init', () => {
  ws.on('/i18n/sync', ({create_tags, delete_tags, modify_tags}) => {
    for (const tag of create_tags) {
      const {path, value} = tag
      pathCreate($s.workspace.i18n, path, value, $s.workspace.config.languages.target, value.target)
    }
    for (const tag of delete_tags) {
      const {path} = tag
      pathDelete($s.workspace.i18n, path)
    }
    for (const tag of modify_tags) {
      const {path, value} = tag
      pathUpdate($s.workspace.i18n, path, value)
    }
  })

  // Handle full i18n state updates
  ws.on('/i18n/state', ({workspace_id, i18n, timestamp}) => {
    if (!$s.workspace || $s.workspace.config.workspace_id !== workspace_id) {
      return
    }

    // Check if this update is newer (prevents race conditions)
    if (!$s.workspace.lastStateUpdateTime || timestamp > ($s.workspace.lastStateUpdateTime ?? 0)) {
      $s.workspace.i18n = i18n
      $s.workspace.lastStateUpdateTime = timestamp
    }
  })
})
```

**WebSocket API Calls:**
```tsx
// ✅ Direct WebSocket API usage
const handleUndo = async () => {
  ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/undo`, {})
}

const handleRedo = async () => {
  ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/redo`, {})
}

// ✅ WebSocket connection management
const Main = () => {
  useEffect(() => {
    (async() => {
      const context = await api.get('/api/context')
      if (context.authenticated) {
        ws.connect() // Connect WebSocket when authenticated
      }
    })()
  }, [])
}
```

## Translation Interface Patterns

### Translation Workflow UX
1. **Translation Groups**: Organize related translations logically
2. **Real-time Progress**: Show live translation status updates
3. **Validation States**: Display errors/warnings clearly
4. **Workspace Context**: Always show current workspace state

### UI Components for i18n
```tsx
// Translation status indicator
const TranslationStatus = ({ status }: { status: TranslationStatus }) => (
  <span class={`translation-status translation-status--${status}`}>
    {status === 'pending' && '⏳'}
    {status === 'translated' && '✅'}
    {status === 'reviewed' && '🔍'}
  </span>
);

// Translation result display
const TranslationResult = ({ original, translated, confidence }) => (
  <div class="translation-result">
    <div class="translation-result__original">{original}</div>
    <div class="translation-result__translated">{translated}</div>
    <div class="translation-result__confidence">
      Confidence: {Math.round(confidence * 100)}%
    </div>
  </div>
);
```

### Icon Component Usage
```tsx
// ✅ Use Icon component from common library
import {Icon} from '@garage44/common/components'

const TranslateButton = () => (
  <button class="translate-button">
    <Icon name="translate" />
    Translate
  </button>
)

// ✅ Real example from main component
const Navigation = () => (
  <div class="menu-group">
    <Link activeClassName="active" href="/">
      <Icon name="settings" type="info"/>
      <span>{$t('menu.settings')}</span>
    </Link>
    <Link href={`/workspaces/${$s.workspace.config.workspace_id}/translations`}>
      <Icon name="translate" type="info"/>
      <span>{$t('menu.workspace.translations')}</span>
    </Link>
  </div>
)

// ✅ Icon with click handlers
const HistoryActions = () => (
  <div class="history-actions">
    <Icon
      name="chevron_left"
      onClick={async() => {
        ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/undo`, {})
      }}
      tip="Undo"
      type="info"
    />
    <Icon
      name="chevron_right"
      onClick={async() => {
        ws.post(`/api/workspaces/${$s.workspace.config.workspace_id}/redo`, {})
      }}
      tip="Redo"
      type="info"
    />
  </div>
)

// ❌ Don't use direct SVG or font icons
const BadComponent = () => (
  <div>
    <svg viewBox="0 0 24 24">...</svg> {/* Wrong! */}
    <i class="fas fa-check"></i> {/* Wrong! */}
    <span>🔍</span> {/* Wrong! Use Icon component */}
  </div>
)
```

## File Organization

### Import Order
```tsx
// Global app imports
import {$s, ws} from '@/app'
import {$t, api, notify} from '@garage44/common/app'

// External dependencies
import {h} from 'preact'
import {useEffect} from 'preact/hooks'
import {Router, route} from 'preact-router'

// Common package imports
import {Icon, Notifications} from '@garage44/common/components'
import {deepSignal} from 'deepsignal'
import {classes} from '@garage44/common/lib/utils'

// Component imports
import {TranslationGroup} from '@/components/elements'

// Relative imports
import './translation-group.css'
```

### File Naming Conventions
- Components: `translation-group.tsx`
- Styles: `translation-group.css` (modern CSS with nesting)
- Barrel exports: `elements.ts`
- Hooks: `useWebSocketSubscription.ts`

### CSS Class Naming
- Root element: `.c-{component-name}` (e.g., `.c-button`, `.c-card`)
- Child elements: Use nesting, not BEM (e.g., `.item` inside `.c-card`, not `.c-card__item`)
- State modifiers: Use `&.modifier` nesting (e.g., `&.active`, `&.disabled`)

## Performance Optimization

### Translation Data Handling
- Lazy load large translation sets
- Virtualize translation lists with 100+ items
- Debounce search/filter inputs (300ms)
- Use signal batching for bulk updates

### Re-render Optimization
```tsx
// ✅ Local state for component filtering
import {deepSignal} from 'deepsignal'

const TranslationComponent = () => {
  const localState = deepSignal({
    filter: '',
    sort: 'asc' as 'asc' | 'desc'
  })

  // Filter translations directly - reactive to localState changes
  const filteredTranslations = $s.workspace.i18n.filter(t =>
    t.key.toLowerCase().includes(localState.filter.toLowerCase())
  )

  return <div>
    <input
      value={localState.filter}
      onInput={e => localState.filter = (e.target as HTMLInputElement).value}
    />
    <TranslationGroup
      group={{_id: 'root', ...$s.workspace.i18n}}
      filter={localState.filter}
      sort={localState.sort}
    />
  </div>
}

// ✅ Pass signals to form fields for performance
const WorkspaceSelector = () => (
  <FieldSelect
    model={state.$workspace_id}  // Signal passed directly
    onChange={async(workspace_id) => {
      $s.workspace = await ws.get(`/api/workspaces/${workspace_id}`)
    }}
    options={$s.workspaces.map(i => ({id: i.workspace_id, name: i.workspace_id}))}
  />
)

// ❌ Don't recreate objects in render
const BadList = () => {
  return translations.map(t => <Item data={{...t, extra: 'data'}} />) // Creates new objects
}
```

## Accessibility for i18n

- Use semantic HTML for translation content
- Provide ARIA labels for translation status
- Ensure keyboard navigation works for translation tables
- Test with screen readers for multilingual content
- Support high contrast mode for translation interfaces

## Development Workflow

### Hot Reload Behavior
- `.tsx` changes: Component hot reload
- `.css` changes: Style injection without reload
- Signal state: Preserved during development
- WebSocket: Automatically reconnects

### Debugging Frontend
- Use Preact DevTools for component inspection
- Monitor WebSocket messages in Network tab
- Check signal updates in browser console
- Validate translation data flow in real-time

## Common Anti-patterns

❌ **Don't do:**
- Use useState instead of deepSignal for component state
- Define deepSignal state inside components (causes infinite re-renders)
- Include functions in useEffect dependencies that depend on signals
- Create inline styles - use CSS classes with modern nesting
- Use direct SVG/font icons - use Icon component
- Use BEM naming (`.c-button__icon`) - use nesting instead
- Mutate props directly
- Block the UI during translation API calls
- Forget to handle WebSocket disconnections
- Use .value syntax with DeepSignal (it's not needed)
- Forget to import global state with `{$s, ws} from '@/app'`
- Create utility CSS classes - create components instead
- Pass non-signal values to Field model props
- Forget to pass validation prop to Field components

✅ **Do:**
- Define deepSignal state OUTSIDE components for stability
- Use deepSignal for component-level reactive state
- Pass signals directly to Field components (model={state.$field})
- Include validation prop in Field components
- Access global state through $s object
- Use existing CSS custom properties (var(--spacer-1), var(--font-d))
- Use Icon component from @garage44/common/components
- Handle loading/error states gracefully
- Access underlying signals with $ prefix for form fields
- Use WebSocket events with `events.on('app:init', ...)` pattern
- Test with multiple languages and character sets
- Use modern CSS nesting in component CSS files
- Extract reusable patterns as components, not utility classes
- Keep useEffect dependencies minimal and stable